# КОММЕНТАРИЙ: я так понял, что у вас не получилось импортировать файл с именем "# ref 5.py" и вы создали копию без пробелов?
# СДЕЛАТЬ: если да, то надо было файлы ref_5 и ref_7 тоже загрузить в удалённый репозиторий — в будущем, если создаёте свои доп.файлы, то грузите и их, не стесняйтесь
# import ref_5
# ИСПОЛЬЗОВАТЬ: а вообще для такого импорта используется явное создание модуля из файла — то есть мы залазим под капот инструкции import — я покажу как это делается: ничего сложного, но с непривычки выглядит страшненько ))
# Path — класс для работы с путями
from pathlib import Path
# path — системный список путей, пополняемый самим интерпретатором
# modules — системный словарь объектов модулей
from sys import path, modules
# инструменты явного импорта
from importlib.util import spec_from_file_location, module_from_spec
# путь к каталогу с нашими файлами
script_dir = Path(path[0])
# путь к импортируемому файлу
module_path = script_dir / '# ref 5.py'
# эта строка в дальнейшем будет использоваться как имя модуля и ключ системного словаря и, с учётом этого, может быть любой
key = '# ref 5'
# создание объекта спецификации модуля
spec = spec_from_file_location(key, module_path)
# создание объекта модуля
ref_5 = module_from_spec(spec)
# добавление в системный словарь элемента с именем и объектом модуля
modules[key] = ref_5
# выполнение модуля
spec.loader.exec_module(ref_5)
# теперь модуль находится в нашем глобальном пространстве имён и, чтобы к нему обратиться, мы используем переменную ref_5

word = input('Введите слово: ').upper().replace('Ё', 'Е')

scores = 0

# ИСПОЛЬЗОВАТЬ: в циклах, генераторных выражениях итп давать переменным осмысленные имена ещё важнее!
print(sum(
    # ИСПРАВИТЬ: может, здесь подразумевается некая перспектива, но для кода в текущем виде значение scores на каждой итерации будет равно нулю
    # КОММЕНТАРИЙ: а если подразумевается, что значение scores будет меняться, то это двойная ошибка: 1) int объекты являются неизменяемыми; 2) если бы были изменяемыми и вы бы как-то прописали это изменение на каждой итерации, то каждое число, возвращаемое генератором во время итерации, содержало бы сумму всех предыдущих очков и очки за очередную букву — а потом все эти числа вы ещё снаружи суммируете функцией sum() — итог вышел бы сильно больше ожидаемого числа
    scores + score
    # ИСПОЛЬЗОВАТЬ: имена переменных i, j, k традиционно используются почти только для индексов
    for char in word for score, letters in ref_5.scores_letters.items()
    if char in letters
    # СДЕЛАТЬ: напишите генераторную функцию, эквивалентную данному генераторному выражению, и поэкспериментируйте с разными способами суммирования
))


# Введите слово: радость
# 10


# ИТОГ: почти хорошо, но требует осмысления — 4/6
