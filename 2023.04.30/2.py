# ОТВЕТИТЬ: какой, однако, оригинальный способ создания пустого списка... это чтобы мне удобнее было отслеживать копипастеров?))
fruits = "".split()

while True:
    fruit = input("Введите название фрукта: ")
    # ИСПОЛЬЗОВАТЬ: вспоминаем про неявное приведение объектов к логическим значениям: пустая строка в отличие от не пустой вернёт False
    if fruit:
        fruits.append(fruit)
    else:
        break
    # КОММЕНТАРИЙ: а ещё в таких ситуациях лучше прописывать условие выхода из цикла, а не условие продолжения цикла, потому что таких выходов может быть несколько в теле сложного цикла:
    # ... возможное начало тела цикла
    # if not fruit:
    #     break
    # fruits.append(fruit)
    # ... возможное продолжение тела цикла
    # ... ещё возможное условие выхода

if len(fruits) >= 2:
    # УДАЛИТЬ: добавлять новые элементы — плохая идея; согласитесь, что 'и' на фрукт не тянет
    fruits.insert(-1, "и")
    # ИСПОЛЬЗОВАТЬ: вот для индексов как раз можно и нужно использовать имя i
    for i in range(0, len(fruits) - 3):
        # УДАЛИТЬ: менять значения элементов — плохая идея; задача стояла в, дословно: "генерировании форматированной строки"
        # КОММЕНТАРИЙ: к тому же эта часть вашего кода превратится в тыкву, стоит заменить входной список на кортеж — на перспективу об этом тоже неплохо бы думать
        fruits[i] = fruits[i] + ","

# КОММЕНТАРИЙ-подсказка: решение второй части задачи укладывается в одну строчку кода, немного похожую на эту
print(" ".join(fruits))


# Введите название фрукта: банан
# Введите название фрукта: апельсин
# Введите название фрукта: мандарин
# Введите название фрукта: яблоко
# Введите название фрукта:
# банан, апельсин, мандарин и яблоко


# ИТОГ: нужно лучше, доработать — 1/3
